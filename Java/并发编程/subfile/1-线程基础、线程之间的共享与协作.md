# 线程基础

## 一、认识线程

### 1、进程与线程：

> 对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。
>
> 有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。

进程：是对运行时程序的封装，是**系统进行资源调度和分配的的基本单位，实现了操作系统的并发**；

线程：是进程的子任务，**是CPU调度和分派的基本单位**，**用于保证程序的实时性，实现进程内部的并发；线程是操作系统可识别的最小执行和调度单位**。每个线程都独自占用一个**虚拟处理器**：独自的**寄存器组**，**指令计数器和处理器状态**。每个线程完成不同的任务，但是**共享同一地址空间**（也就是同样的**动态内存，映射文件，目标代码等等**），**打开的文件队列和其他内核资源**。

一句话：**进程是资源分配的最小单位，线程是CPU调度的最小单位**；





### 2、并行与并发：

- 并发：一个处理器同时处理多个任务。
- 并行：多个处理器或者是多核的处理器同时处理多个不同的任务。

**区别：**并发和并行的区别就是一个人同时吃三个馒头和三个人同时吃三个馒头。

![](../images/Mac_2021-10-31_14-30-46.png)





### 3、Java创建线程的方式：

> - **1.继承Thread类，重写run方法**
> - **2.实现Runnable接口，重写run方法，实现Runnable接口的实现类的实例对象作为Thread构造函数的target**
> - **3.通过Callable和FutureTask创建线程**
> - **4.通过线程池创建线程**

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

/**
 * @author The_Beatles
 * @date 2021/10/31 10:12
 */

public class NewThread {

    private static class UserThread extends Thread {
        @Override
        public void run() {
            System.out.println("I am extends Thread.");
        }
    }

    // 由于Java中只能实现单继承，如果采用方式一，则线程类就无法继承其他类了，所以实现Runnable接口创建线程的方式更受欢迎。
    private static class UserRun implements Runnable {

        @Override
        public void run() {
            System.out.println("I am implements Runnable.");
        }
    }

    // 在前面两种线程创建方式中，线程执行完毕后并没有返回值，而实现Callable接口创建线程可以在线程结束后返回一个值。
    private static class UserCall implements Callable<String> {

        @Override
        public String call() throws Exception {
            return "I am implements Callable.";
        }
    }

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // Thread
        new UserThread().start();
        // Runnable
        new Thread(new UserRun()).start();
        // Callable
        FutureTask<String> futureTask = new FutureTask<>(new UserCall());
        new Thread(futureTask).start();
        System.out.println(futureTask.get());
    }
}
```





### 4、创建线程的对比：
- a.采用实现Runnable、Callable接口的方式创建多线程时:

**优势是：**

线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。

在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。

**劣势是：**

编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。

- b.使用继承Thread类的方式创建多线程时

**优势是：**

编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。

**劣势是：**

线程类已经继承了Thread类，所以不能再继承其他父类。

- c.Runnable和Callable的区别

(1) Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()。

(2) Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。

(3) call方法可以抛出异常，run方法不可以。

(4) 运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。





### 5、停止线程：

> 1、自然执行完。
>
> 2、抛出异常。

#### **相关API介绍：**

**stop()**：其实stop方法天生就不安全，因为它在终止一个线程时会==强制中断线程==的执行，不管run方法是否执行完了，并且还会==释放这个线程所持有的所有的锁对象==。这一现象会被其它因为请求锁而阻塞的线程看到，使他们继续向下执行。这就会造成数据的不一致。

我们拿银行转账作为例子，我们还是从A账户向B账户转账500元，我们之前讨论过，这一过程分为三步，第一步是从A账户中减去500元，假如到这时线程就被stop了，那么这个线程就会释放它所取得锁，然后其他的线程继续执行，这样A账户就莫名其妙的少了500元而B账户也没有收到钱。这就是stop方法的不安全性。

**resume()**：`Thread`类的`resume()`方法仅用于`suspend()`方法。 此方法用于恢复使用`suspend()`方法挂起的线程。此方法允许挂起的线程再次启动。

**suspend()**：suspend被弃用的原因是因为它会造成==死锁==。suspend方法和stop方法不一样，它==不会破坏对象和强制释放锁==，相反它==会一直保持对锁的占有==，一直到其他的线程调用resume方法，它才能继续向下执行。

假如有A，B两个线程，A线程在获得某个锁之后被suspend()阻塞，这时A不能继续执行，线程B在获得相同的锁之后才能调用resume方法将A唤醒，但是此时的锁被A占有，B不能继续执行，也就不能及时的唤醒A，此时A，B两个线程都不能继续向下执行而形成了死锁。这就是suspend()被弃用的原因。

**interrupt()**：interrupt()方法用于中断一个线程，而Java中线程的处理是**`协作式`**的而不是抢占式的。实际上调用一个线程的interrupt()方法中断一个线程，并不是强行关闭这个线程，只是跟这个线程打个招呼，将线程的中断标志位置为true，线程是否中断，由线程本身决定。interrupt方法的目的**是给线程发出中断信号，但是不保证线程真的会中断**。

> 如果线程在调用 Object类的 wait()、wait(long) 或 wait(long, int) 方法，或者该Thread类的 join()、join(long)、join(long, int)、sleep(long) 或 sleep(long, int) 方法过程中受阻，则其中断状态将被清除，它还将收到一个InterruptedException异常。这个时候，我们可以通过捕获InterruptedException异常来终止线程的执行，具体可以通过return等退出或改变共享变量的值使其退出。

**isInterrupt()**：

public boolean isInterrupted() 判断线程是否已经中断。线程的“中断状态”不受该方法的影响。

```java
    public boolean isInterrupted() {
        return isInterrupted(false);
    }
    private native boolean isInterrupted(boolean ClearInterrupted);
```

**static方法interrupted()**：

public static boolean interrupted 判断当前线程是否已经中断。线程的“中断状态”由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回 false。

```java
   public static boolean interrupted() {
        return currentThread().isInterrupted(true);
    }
```

**InterruptException:**

```java
/**
 * @author The_Beatles
 * @date 2021/10/31 11:43
 */

public class HasInterruptException {

    private static class UserThread extends Thread {

        public UserThread(String name) {
            super(name);
        }

        @Override
        public void run() {
            String threadName = Thread.currentThread().getName();
            while (!isInterrupted()) {
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    System.out.println(threadName + " is isInterrupt flag is " + isInterrupted());
                    e.printStackTrace();
                    interrupt();
                }
                System.out.println(threadName + " is run!");
            }
            System.out.println(threadName + " is isInterrupt flag is ---" + isInterrupted());
        }
    }

    public static void main(String[] args) throws InterruptedException {
        UserThread endThread = new UserThread("HasInterruptException");
        endThread.start();
        Thread.sleep(100);
        endThread.interrupt();
    }
}
```



**==interrupt机制：==**

Java`中断响应`是描述当一个线程或方法A处于运行、阻塞或死锁状态时，外界(通常指其他线程、系统IO等)对A的影响能否让A线程或者方法抛出InterruptedException异常并提前返回，如果会提前返回并且抛出InterruptedException，就叫**可中断响应方法或线程**，如果不会抛出InterruptedException，就叫**不可中断线程或方法**。

Java语言中所有阻塞方法都声明抛出InterruptedException异常（例如 `Thread.sleep()`、 `Thread.join()` 或 `Object.wait()`）。也就是说，如果一个线程执行了阻塞方法，使得当前线阻塞，第三方线程执行interrupt方法中断线程，都会使得该阻塞方法抛出InterruptedException异常并退出阻塞，**并且将当前线程的中断标志位设置为false**。

如果没有这个机制， `interrupt()` 则只是单纯设置线程的中断状态。那这个试图中断的线程仍在阻塞当中，那么后序的中断工作则无法进行。

> 当外部线程对某线程调用了thread.interrupt()方法后，java语言的处理机制如下： 
> 1、如果该线程处在**可中断状态**下，（调用了xx.wait()，或者Selector.select(),Thread.sleep()等特定会发生阻塞的api），那么该线程会立即被唤醒，同时会受到一个InterruptedException，同时，如果是*阻塞在io上，对应的资源会被关闭*。如果该线程接下来不执行“Thread.interrupted()方法（不是interrupt），那么该线程处理任何io资源的时候，都会导致这些资源关闭。当然，解决的办法就是调用一下interrupted()，不过这里需要程序员自行根据代码的逻辑来设定，根据自己的需求确认是否可以直接忽略该中断，还是应该马上退出。 
> 2、如果该线程处在**不可中断状态**下，就是没有调用上述api，那么java只是设置一下该线程的interrupt状态，其他事情都不会发生，如果该线程之后会调用上述阻塞API，那到时候线程会马上跳出，并抛出InterruptedException，接下来的事情就跟第一种状况一致了。如果不会调用阻塞API，那么这个线程就会一直执行下去。除非你就是要实现这样的线程，一般高性能的代码中肯定会有wait()，yield()之类出让cpu的函数，不会发生后者的情况。



**==Thread.interrupt() VS Thread.stop()：==**

> 这两个方法最大的区别在于：**interrupt（）方法是设置线程的中断状态，让用户自己选择时间地点去结束线程；而stop（）方法会在代码的运行处直接抛出一个ThreadDeath错误，这是一个java.lang.Error的子类。所以直接使用stop（）方法就有可能造成对象的不一致性。** 
> 在JAVA中，曾经使用stop方法来停止线程，然而，该方法具有固有的不安全性，因而已经被抛弃(Deprecated)。那么应该怎么结束一个进程呢？官方文档中对此有详细说明：《为何不赞成使用 Thread.stop、Thread.suspend 和 Thread.resume？》。在此引用stop方法的说明： 
>
> Why is Thread.stop deprecated? 
> Because it is inherently unsafe. Stopping a thread causes it to unlock all the monitors that it has locked. (The monitors are unlocked as the ThreadDeath exception propagates up the stack.) If any of the objects previously protected by these monitors were in an inconsistent state, other threads may now view these objects in an inconsistent state. Such objects are said to be damaged. When threads operate on damaged objects, arbitrary behavior can result. This behavior may be subtle and difficult to detect, or it may be pronounced. Unlike other unchecked exceptions, ThreadDeath kills threads silently; thus, the user has no warning that his program may be corrupted. The corruption can manifest itself at any time after the actual damage occurs, even hours or days in the future. 
>
> 大概意思是： 
> 因为该方法本质上是不安全的。停止一个线程将释放它已经锁定的所有监视器（作为沿堆栈向上传播的未检查 ThreadDeath 异常的一个自然后果）。如果以前受这些监视器保护的任何对象都处于一种不一致的状态，则损坏的对象将对其他线程可见，这有可能导致任意的行为。此行为可能是微妙的，难以察觉，也可能是显著的。不像其他的未检查异常，ThreadDeath异常会在后台杀死线程，因此，用户并不会得到警告，提示他的程序可能已损坏。这种损坏有可能在实际破坏发生之后的任何时间表现出来，也有可能在多小时甚至在未来的很多天后。 
> 在文档中还提到，程序员不能通过捕获ThreadDeath异常来修复已破坏的对象。具体原因见原文。





### 6、线程的状态

#### a.线程的生命周期

![](../images/javaThread.png)





#### **b.Java的线程状态有以下五种：**

1. 新建状态（NEW）

   用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态（runnable）。

2. 就绪状态（READY）

   在就绪下，线程进入到了可运行池，等待分配CPU。当系统选定一个等待执行的Thread对象后，它就会从等待执行状态进入执行状态，系统挑选的动作称之为“CPU调度”。一旦获得CPU时间片(`timeslice`)，线程就进入运行状态并自动调用自己的run方法。

3. 运行状态（RUNNABLE）

   处于运行状态的线程执行`run()`方法。如果该线程失去了CPU资源，会从运行状态变回就绪状态，重新等待系统分配资源。可以使用`yield()`方法使其让出CPU资源，再次变为就绪状态。

4. 阻塞状态（BLOCKED、WAITING、TIMED_WAITING）

   阻塞状态是指线程自动或被动让出CPU并暂停自己的运行(也即让出了`cpu timeslice`)。当引起阻塞的原因消除时，阻塞才能回到就绪状态等待被系统选中。

5. 死亡状态（TERMINATED）

   当线程`run()`方法执行完或者被强制终止，就认为它进入死亡状态。一旦线程死亡，就不能复生。



#### **c.状态的转变:**

- **新建状态 -> 就绪状态**

`Thread.start()` —— 使该线程开始执行；Java虚拟机调用该线程的`run`方法。

- **就绪状态 -> 运行状态**

`yield()`—— 暂停当前正在执行的线程对象，并执行其他线程。

- **运行状态 -> 阻塞状态**

当发生如下情况时，线程将会**进入阻塞状态**：

1. 线程调用`sleep()`方法主动放弃所占用的处理器资源，进入超时等待状态（TIMED_WAITING）
2. 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞
3. 线程试图获得一个同步监视器(:lock:)，但该同步监视器正被其他线程所持有，进入BLOCKED状态。
4. 线程在等待某个通知`notify`
5. 程序调用了线程的`suspend()`方法将该线程挂起。这个方法容易导致死锁，所以应该尽量避免使用该方法。

- **阻塞状态 -> 运行状态**

解除阻塞，让线程重新进入就绪状态：

1. 调用`sleep()`方法的线程经过了指定时间。
2. 线程调用的阻塞式IO方法已经返回。
3. 线程成功地获得了试图取得的**同步监视器（锁）**:lock:。
4. 线程正在等待某个通知时，其他线程发出了个**通知**。
5. 处于挂起状态的线程被调用了恢复方法。

- **运行状态 -> 死亡状态**

线程会以如下三种方式结束，结束后处于死亡状态：

1. `run()`, `call()`方法执行结束，线程便正常结束
2. 线程抛出一个未捕获的 Exception 或 Error
3. 直接调用该线程stop()方法来结束该线程——该方法容易导致死锁，通常不推荐使用。



#### **d.状态的获取:**

调用线程对象的`isAlive()`方法，当线程处于就绪、运行、阻塞了种状态时，该方法将返回true；当线程处于新建、死亡状态时，该方法将返回false。

```java
/**
 * 线程开始或结束状态的判断
 */
public class ThreadStartEnd extends Thread{

    private int i;

    public void run(){
        for (; i < 100; i++) {
            System.out.println(getName() + " - "+ i);
        }
    }

    public static void main(String[] args) {
        // 创建线程
        ThreadStartEnd thread = new ThreadStartEnd();
        for (int i = 0; i < 300; i++) {
            System.out.println("Current Thread: "+currentThread().getName()+", i= "+i);
            if (i==20){
                thread.start();
                // 判断线程启动状态
                System.out.println("isAlive? "+thread.isAlive());
            }
            // 当线程死亡时再次启动，观察反应
            // 结果是该死亡线程无法再次启动
            if (i>20 && !thread.isAlive()){
                thread.start();
            }
        }
    }
}
```

`参考:`[https://jimsunjing.github.io/tech/java/JavaThreadLife/]

#### e.扩展：

> - yield()
>
> - - 使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。cpu会从众多的可执行态里选择，也就是说，当前也就是刚刚的那个线程还是有可能会被再次执行到的，并不是说一定会执行其他线程而该线程在下一次中不会执行到了。
>   - 用了yield方法后，该线程就会把CPU时间让掉，让其他或者自己的线程执行（也就是谁先抢到谁执行）
>   - 通过yield方法来实现两个线程的交替执行。不过请注意：这种交替并不一定能得到保证。
>   - yield()只是使当前线程重新回到可执行状态，所有执行yield()的线程有可能在进入到可执行状态后马上又被执行，所以yield()方法只能使同优先级的线程有执行的机会。



> **多线程原理：**
>
> 我们一般使用thread new一个线程，然后调用start方法启动，线程就会处于运行状态中ready，等待CPU调度，然后再执行线程里面的run()方法，使用start方法才真正实现了多线程运行，因为这个时候不用等待我们的run方法执行完成就可以继续执行下面的代码，这才叫多线程。
>
> 如果直接使用thread执行run方法会怎么样呢？
>
> 因为run方法是thread里面的一个普通的方法，如果直接调用run()方法，这个时候它会运行在主线程中，因为程序中只有主线程一个线程，如果有两个线程，都是直接调用run()方法，那么他们的执行顺序一定是按顺序执行的，并没有实现多线程的目的。

1、使用Thread 创建一个线程，然后调用start方法启动：

```java
/**
 * @author The_Beatles
 * @date 2021/10/31 16:25
 */

public class StartThread {

    private static class UserThread extends Thread {

        @Override
        public void run() {
            int i = 5;
            while (i > 0) {
                System.out.println(Thread.currentThread().getName() + "[" + i-- + "]: is run!");
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        UserThread userThread = new UserThread();
        userThread.setName("UserThread");
        userThread.start();
//        userThread.run();

    }
}
```

结果：

```java
UserThread[5]: is run!
UserThread[4]: is run!
UserThread[3]: is run!
UserThread[2]: is run!
UserThread[1]: is run!

Process finished with exit code 0
```

2、通过main方法（主程序）运行run方法：

```java
public static void main(String[] args) throws InterruptedException {
        UserThread userThread = new UserThread();
        userThread.setName("UserThread");
//        userThread.start();
        userThread.run();

    }
```

结果：

```java
main[5]: is run!
main[4]: is run!
main[3]: is run!
main[2]: is run!
main[1]: is run!

Process finished with exit code 0
```

3、先执行上面的1、再执行2：

```java
public static void main(String[] args) throws InterruptedException {
        UserThread userThread = new UserThread();
        userThread.setName("UserThread");
        userThread.start();
        userThread.run();
    }
```

结果：

```java
UserThread[5]: is run!
UserThread[4]: is run!
main[5]: is run!
main[4]: is run!
main[3]: is run!
main[2]: is run!
main[1]: is run!
UserThread[3]: is run!
UserThread[2]: is run!
UserThread[1]: is run!

Process finished with exit code 0
```

4、先执行上面的2，再执行1：

```java
public static void main(String[] args) throws InterruptedException {
        UserThread userThread = new UserThread();
        userThread.setName("UserThread");
        userThread.run();
        userThread.start();
    }
```

结果：

```java
main[5]: is run!
main[4]: is run!
main[3]: is run!
main[2]: is run!
main[1]: is run!
UserThread[5]: is run!
UserThread[4]: is run!
UserThread[3]: is run!
UserThread[2]: is run!
UserThread[1]: is run!

Process finished with exit code 0
```





### 7、守护线程

> **守护线程**是一种特殊的线程，在后台默默地完成一些系统性的服务，比如垃圾回收线程、JIT线程都是守护线程。与之对应的是用户线程，用户线程可以理解为是系统的工作线程，它会完成这个程序需要完成的业务操作。如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出了。所以当系统只剩下守护进程的时候，[java](http://www.cppcns.com/ruanjian/javabiancheng/)虚拟机会自动退出。
>
> java线程分为用户线程和守护线程，线程的daemon属性为true表示是守护线程(`Daemon Thread`)，false表示是用户线程(`User Thread`)。
>
> 最经典的守护线程使用就是负责GC的线程。只要用户线程还在，他就会认认真真的执行自己的工作。
>
> - 守护线程的优先级是最低的。

将线程转换为守护线程可以通过调用`Thread`对象的`setDaemon(true)`方法来实现。在使用守护线程时需要注意一下几点：

(1) `thread.setDaemon(true)`必须在`thread.start()`之前设置，否则会跑出一个`IllegalThreadStateException`异常。你不能把正在运行的常规线程设置为守护线程。

```java
public class Test {
    public static void main(String[] args) {
        Thread t = new Thread(()->{
            while(true){
                System.out.println("我是守护线程t，我在运行");
            }
        });
        t.setDaemon(true);
        t.start();
//        try {
//            TimeUnit.SECONDS.sleep(1);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }
    }
}

//这样执行起来什么也打印不了，但如果把注释去掉，让主线程停一秒就会持续打印。
```

(2) 在守护线程线程中产生的新线程也是守护线程。

```java
public class Test {
    public static void main(String[] args) {
        Thread t = new Thread(()->{
            Thread a = new Thread(()->{
                while (true){
                    System.out.println("我是线程a,我在运行");
                }
            });
            a.start();
        });
        t.setDaemon(true);
        t.start();
//        try {
//            TimeUnit.SECONDS.sleep(1);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }
    }
}

//这样执行起来什么也打印不了，但如果把注释去掉，让主线程停一秒就会持续打印。这就证明了a也是守护线程
```

(3) 守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。

另外 调用`thread`对象的IsDaemon()可以获得该对象是否为守护线程。

```java
public static void main(String[] args) {
    Thread t = new Thread(()->{
        Thread a = new Thread(()->{
            while (true){
                //System.out.println("我是线程a,我在运行");
            }
        });
        System.out.println(a.isDaemon());
        a.setDaemon(false);
        System.out.println(a.isDaemon());
        a.start();
    });
    t.setDaemon(true);
    t.start();
    try {
        TimeUnit.MILLISECONDS.sleep(200);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}

//打印结果是true和false。a可以一直运行
```

4、在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。(守护进程是随着虚拟机的停止而停止运行的，你不可能预料到虚拟机何时停止，而如果在守护线程拥有类似finally代码块的语句，那么这些语句很有可能没有机会运行)

```java
/**
 * @author The_Beatles
 * @date 2021/10/31 16:40
 */

public class DaemonThread {

    private static class UserThread extends Thread {

        @Override
        public void run() {
            try {
                while (!isInterrupted()) {
                    System.out.println(Thread.currentThread().getName() + " is run!");
                }
                System.out.println(Thread.currentThread().getName() + " is isInterrupt flag is " + isInterrupted());
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                System.out.println("。。。。。。。。。finally");
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        UserThread userThread = new UserThread();
        userThread.setDaemon(true); // 在start方法前使用
        userThread.start();
        Thread.sleep(5);
//        userThread.interrupt();
    }
}
```





## 二、线程的共享

### 1、synchronized

> 说明：`sychronized`可以作用于**变量、方法和类，但是不能作用于null。**
>
> synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：
>
> 修饰一个方法
>
> 被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；
>
> 修饰一个静态的方法
>
> 其作用的范围是整个静态方法，作用的对象是这个类的所有对象；
>
> 修饰一个代码块
>
> 被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；
>
> 修饰一个类
>
> 其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。

**对象锁：**

当一个对象中有`synchronized method` 或`synchronized block` 的时候，调用此对象的同步方法或进入其同步区域时，就必须先获得对象锁。如果此对象的对象锁已被其他调用者占用，则需要等待此锁被释放。java的所有对象都含有1个互斥锁，这个锁由JVM自动获取和释放。线程进入`synchronized`方法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁，那么当前线程会等待；`synchronized`方法正常返回或者抛异常而终止，JVM会自动释放对象锁。

- 理解：

  <u>用来控制同一个实例在不同线程中的同步</u>

  - 修饰普通方法：即方法中增加`synchronized`关键字。
  - `synchronized(this)`或者`synchronized(某一个实例)`

**两个线程中分别访问同一个对象的同步方法，会互斥；不同对象的同步方法，不会互斥**



**类锁**：

由于一个class不论被实例化多少次，其中的静态方法和静态变量在内存中都只有一份。所以，一旦一个静态的方法被申明为`synchronized`。此类所有的实例化对象在调用此方法，共用同一把锁，我们称之为类锁。所谓的类锁，不过是Class对象的锁而已。

- 理解：

  <u>是用来控制静态方法（或静态变量互斥体）之间的同步</u>

  - 修饰静态方法（或静态代码块）
  - synchronized(xx.class)

两个线程中调用同一个类的两个不同的同步方法，会互斥



**代码示例：**

```java
import java.util.concurrent.TimeUnit;

/**
 * @author The_Beatles
 * @date 2021/10/31 17:48
 */

public class SyncClzAndInst {

    // 使用类🔐的线程
    private static class SynClass extends Thread {
        @Override
        public void run() {
            System.out.println("TestClass is running...");
            synClass();
        }
    }

    // 使用对象🔐的线程
    private static class InstanceSyn implements Runnable {
        private SyncClzAndInst syncClzAndInst;

        public InstanceSyn(SyncClzAndInst syncClzAndInst) {
            this.syncClzAndInst = syncClzAndInst;
        }

        @Override
        public void run() {
            System.out.println("TestInstance is running..." + syncClzAndInst);
            syncClzAndInst.instance();
        }
    }

    // 使用对象🔐的线程
    private static class Instance2Syn implements Runnable {
        private SyncClzAndInst syncClzAndInst;

        public Instance2Syn(SyncClzAndInst syncClzAndInst) {
            this.syncClzAndInst = syncClzAndInst;
        }

        @Override
        public void run() {
            System.out.println("TestInstance2 is running..." + syncClzAndInst);
            syncClzAndInst.instance2();
        }
    }

    // 使用对象🔐的方法
    private synchronized void instance() {
        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("synInstance is going..." + this);
        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("synInstance end..." + this);
    }

    // 使用对象🔐的方法
    private synchronized void instance2() {
        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("synInstance2 is going..." + this);
        try {
            TimeUnit.SECONDS.sleep(3);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("synInstance2 end..." + this);
    }

    // 使用类🔐的方法
    private static synchronized void synClass() {
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("synClass going...");
        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("synClass end...");
    }

    public static void main(String[] args) {
        SyncClzAndInst syncClzAndInst = new SyncClzAndInst();
        Thread t1 = new Thread(new InstanceSyn(syncClzAndInst));

//        SyncClzAndInst syncClzAndInst2 = new SyncClzAndInst();
//        Thread t2 = new Thread(new Instance2Syn(syncClzAndInst));

        t1.start();
//        t2.start();

        SynClass synClass = new SynClass();
        synClass.start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```



**注意**：

- `sychronized`对于同一个监视锁可以获取多次

```java
// Example
class Test {
  public static void main(String[] args) {
    Test t = new Test();
    synchronized (t) {
      synchronized (t) {
        System.out.println("made it!");
      }
    }
  }
}

// This program produces the output:
made it!
```

- 禁止基于可被重用的对象进行同步

错误❌：

```java
private final Boolean lock = Boolean.FALSE;
private final Integer lock = 0;
private final String lock = "guan";
private final String lock = new String("guan").intern();

// 语法不对，synchronized的锁只能是对象，而不是基本数据类型
private final int lock = 0;

// 加锁
synchronized (lock) {
	// 具体事务......
}
```

正确✅：

```java
// -128-127之间的是Integer的缓存对象
private final Integer lock = 128; // 这种方式确实有效，但不知道是否符合编程规范
private final Integer lock = new Integer(0);
private final String lock = new String("guan");
private final Object lock = new Object();
// 加锁
synchronized (lock) {
	// 具体事务......
}
```



==synchronized底层原理==

> 在Java早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统来实现，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。
>
> 在Java 6之后从JVM层面对synchronized做了较大优化，锁的实现引入了如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。
>
> **synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令。**
>
> 其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。
>
> 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权.当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。
>
> **synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的是ACC_SYNCHRONIZED标识，**该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。但是原理其实都是类似的。

**扩展：**
锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。

**自旋**：当有个线程A去请求某个锁的时候，这个锁正在被其它线程占用，但是线程A并不会马上进入阻塞状态，而是循环请求锁(自旋)。这样做的目的是因为很多时候持有锁的线程会很快释放锁的，线程A可以尝试一直请求锁，没必要被挂起放弃CPU时间片，因为线程被挂起然后到唤醒这个过程开销很大,当然如果线程A自旋指定的时间还没有获得锁，仍然会被挂起。

**自适应性自旋**：自适应性自旋是自旋的升级、优化，自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定。例如线程如果自旋成功了，那么下次自旋的次数会增多，因为JVM认为既然上次成功了，那么这次自旋也很有可能成功，那么它会允许自旋的次数更多。

**锁消除**是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。

**偏向锁**的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那么偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不用做了。偏向锁默认是开启的，也可以关闭。

